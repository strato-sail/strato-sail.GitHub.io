---
layout:     post
title:      "RPC框架Dubbo学习"
subtitle:   "对 Dubbo 的介绍以及学习使用过程"
date:       2021-04-21 12:00:00
author:     "Wangcy"
catalog: false
header-style: text
tags:
  - 分布式
  - RPC
  - Dubbo
---

# 1 Dubbo学习

## 1.1 RPC

【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许<u>程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节</u>。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。

![](\img\in-post\dubbo\dubbo-01.png)

1. 先找一个小助手（client stub），小助手先和服务器建立socket连接，将调用服务器的方法名、方法参数通过网络传递给服务器；
2. 服务器的小助手（server stub）用传递过来的方法名方法参数调用服务器的此方法；
3. 服务器小助手将方法返回值通过socket连接传递回客户端

![](\img\in-post\dubbo\dubbo-02.png)

**影响一个RPC框架性能因素：**

- 能否快速的在各个服务器直接建立网络连接
- 框架中序列化反序列化的速度如何

**常见的RPC框架：**

- dubbo，gRPC，Thrift，HSF（High Speed Service Framework 阿里在使用）



## 1.2 Dubbo介绍

[dubbo官网](https://dubbo.apache.org/zh/)，dubbo官方介绍在 github 中。

**特点：**

- 面向接口代理：调用服务器中接口的方法，会自动找服务器中的代码，屏蔽了远程的调用细节
- 智能的负载均衡：智能找负载低的服务器处理请求
- 服务自动注册与发现：RPC框架怎么知道某个应用在哪些服务器上（注册中心），注册中心维护一个清单（某个应用在哪些服务器上，上下线通知），可以用 zookeeper
- 运行期流量调度：路由策略，灰度发布（让一部分请求使用新版本，慢慢全部过度）
- 可视化运维：可视化web界面

![](\img\in-post\dubbo\dubbo-03.png)

**（调用服务为同步调用，监控信息为异步获取）**

**调用关系：**

1. 框架启动，容器（Container）启动
2. 容器启动后，服务提供者会将自己提供的服务信息注册到服务中心里，服务中心就知道有哪些服务上线了
3. 当服务消费者上线后，会从服务中心订阅它所需要的服务
4. 当某个服务变更后，服务中心和服务消费者基于长连接的方式将服务变更推送给服务消费者
5. 服务消费者调用某个服务后，框架会根据负载均衡算法调度服务提供者某台服务器
6. 每次调用信息，调用时间、调用次数会每隔1分钟发送到服务监控中心进行监控



## 1.3 环境搭建

**1. 搭建服务注册中心**

官方文档推荐使用 **Zookeeper** 搭建服务注册中心。

[Zookeeper学习笔记链接](https://strato-sail.github.io/2021/04/19/zookeeper/)

- `zookeeper`安装包下载，解压。
- 将`zoo_sample.cfg`复制一份为`zoo.cfg`。
- 修改`config`文件中的`dataDir`为相对路径

**2. 安装监控中心**

> dubbo-admin 图形化的服务管理页面，安装时需要指定注册中心地址，即可以从注册中心获取到所有的提供者/消费者进行配置管理。

（可选安装，安装后能 web 可视化形式监控服务调用情况）

- 在官网`github`中下载`dubbo-admain`，我所下版本的[源码下载链接](https://github.com/strato-sail/strato-sail.GitHub.io/tree/main/_posts/dubbo)。

- 将`src/main/resources/application.properties`中`dubbo.registry.address`，改为注册中心的ip加端口号`dubbo.registry.address=zookeeper://127.0.0.1:2181`。

- 在`yourpath\dubbo\incubator-dubbo-ops-master\dubbo-admin`中敲入命令：

  ~~~shell
  <yourpath\incubator-dubbo-ops-master\dubbo-admin> mvn clean package -Dmaven.test.skip=true
  ~~~

- 运行刚刚生成的`jar`包，控制台下输入`java -jar <包名>`（启动之前先启动 Zookeeper）

- 默认端口号为 7001，浏览器输入`http://localhost:7001/`进入管理控制台界面（账号密码默认root/root）

![](\img\in-post\dubbo\dubbo-04.png)

## 1.4 dubbo Hello world

### 需求

| 模块                | 功能           |
| ------------------- | -------------- |
| 订单服务web模块     | 创建订单等     |
| 用户服务service模块 | 查询用户地址等 |

订单服务在服务器A，用户查询服务在服务器B，服务器A远程调用服务器B的查询用户地址功能。

[官网用户手册](https://dubbo.apache.org/zh/docs/v2.7/user/)

可以在订单工程中导入user的接口，然后通过接口调用接口中抽象方法：

![](\img\in-post\dubbo\dubbo-05.png)

但是在官网手册中的[服务化最佳实践](https://dubbo.apache.org/zh/docs/v2.7/user/best-practice/)中如下说明：（**将其他所有服务的接口放在同一个包里**）

![](\img\in-post\dubbo\dubbo-06.png)

### 架构

![放个类图uml](\img\in-post\dubbo\dubbo-10.png)



### 接口文件分包

将服务提供者和服务消费者的接口单独放在一个包里：

![](\img\in-post\dubbo\dubbo-09.png)

bean对象：

~~~java
public class UserAddress implements Serializable {
	
	private Integer id;
    private String userAddress; //用户地址
    private String userId; //用户id
    private String consignee; //收货人
    private String phoneNum; //电话号码
    private String isDefault; //是否为默认地址    Y-是     N-否
    
    //getter setter
    //allarg-constructor
}
~~~

两个接口类：

~~~java
public interface OrderService {
	
	/**
	 * 初始化订单
	 * @param userId
	 */
	public List<UserAddress> initOrder(String userId);

}
~~~

~~~java
public interface UserService {
	
	/**
	 * 按照用户id返回所有的收货地址
	 * @param userId
	 * @return
	 */
	public List<UserAddress> getUserAddressList(String userId);

}
~~~



在服务提供者和服务消费者的`pom`文件里添加如下依赖（注意，添加依赖前先将接口工程使用 maven install  ，将自己的工程装载到本地 maven 仓库里）：

~~~xml
<dependency>
       <groupId>com.wcy</groupId>
       <artifactId>dubbotestinterface</artifactId>
       <version>1.0-SNAPSHOT</version>
</dependency>
~~~



### 服务提供者

[官网快速启动案例](https://dubbo.apache.org/zh/docs/v2.7/user/quick-start/)

将 **服务提供者** 注册到注册中心（如何暴露服务）

1）导入`dubbo`依赖，导入`zookeeper`客户端

~~~xml
<!-- https://mvnrepository.com/artifact/com.alibaba/dubbo -->
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>dubbo</artifactId>
	<version>2.6.2</version>
</dependency>

<!-- https://mvnrepository.com/artifact/org.apache.curator/curator-framework -->
<!-- dubbo 2.6 之前用的客户端是zkClient -->
<!-- dubbo 2.6 及之后用的客户端是curator -->
<dependency>
	<groupId>org.apache.curator</groupId>
	<artifactId>curator-framework</artifactId>
	<version>2.12.0</version>
</dependency>
~~~

2）服务提供者代码实现类

~~~java
public class UserServiceImpl implements UserService {

	@Override
	public List<UserAddress> getUserAddressList(String userId) {
		System.out.println("UserServiceImpl.....old...");
		// TODO Auto-generated method stub
		UserAddress address1 = new UserAddress(1, "北京市昌平区宏福科技园综合楼3层", "1", "李老师", "010-56253825", "Y");
		UserAddress address2 = new UserAddress(2, "深圳市宝安区西部硅谷大厦B座3层（深圳分校）", "1", "王老师", "010-56253825", "N");
		/*try {
			Thread.sleep(4000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}*/
		return Arrays.asList(address1,address2);
	}

}
~~~

主程序启动类：

~~~java
public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext("provider.xml");
        ioc.start();       //启动ioc容器
        System.in.read();  //不让程序停止
    }
}
~~~



3）配置服务提供者

> [官网快速启动案例](https://dubbo.apache.org/zh/docs/v2.7/user/quick-start/)
>
> [zookeeper注册中心配置](https://dubbo.apache.org/zh/docs/v2.7/user/configuration/config-center/)
>
> [所有dubbo标签的作用](https://dubbo.apache.org/zh/docs/v2.7/user/references/xml/)

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">

    <!-- 1. 指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） -->
    <dubbo:application name="dubboTest"></dubbo:application>

    <!-- 2. 指定注册中心的位置 -->
    <dubbo:registry address="zookeeper://127.0.0.1:2181"></dubbo:registry>

    <!-- 3. 指定通信规则（通信协议，通信端口） -->
    <dubbo:protocol name="dubbo" port="20080"></dubbo:protocol>

    <!-- 4. 暴露服务 interface接口全限定类型 ref指向服务真正的实现对象-->
    <dubbo:service interface="com.wcy.dubbotestinterface.service.UserService" ref = "userServiceImpl"></dubbo:service>
    <!-- 服务的实现bean  -->
    <bean id = "userServiceImpl" class="com.wcy.dubboservice.gmall.impl.UserServiceImpl"></bean>

</beans>
~~~

主程序启动 ioc 容器：

~~~java
public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext("provider.xml");
        ioc.start();       //启动ioc容器
        System.in.read();  //不让程序停止
    }
~~~

运行后监控 web 界面发生变化：

![](\img\in-post\dubbo\dubbo-07.png)



![](\img\in-post\dubbo\dubbo-08.png)



### 服务消费者

让服务消费者去注册中心订阅服务提供者的服务地址

1）导入`dubbo`依赖，导入`zookeeper`客户端

2）服务提供者代码实现类

~~~java
/**
 * 1、将服务提供者注册到注册中心（暴露服务）
 * 		1）、导入dubbo依赖（2.6.2）\操作zookeeper的客户端(curator)
 * 		2）、配置服务提供者
 * 
 * 2、让服务消费者去注册中心订阅服务提供者的服务地址
 * @author lfy
 *
 */
@Service
public class OrderServiceImpl implements OrderService {

	@Autowired
	UserService userService;
	@Override
	public List<UserAddress> initOrder(String userId) {
		// TODO Auto-generated method stub
		System.out.println("用户id："+userId);
		//1、查询用户的收货地址
		List<UserAddress> addressList = userService.getUserAddressList(userId);
		for (UserAddress userAddress : addressList) {
			System.out.println(userAddress.getUserAddress());
		}
		return addressList;
	}
}
~~~

主程序启动类

~~~java
public class MainApplication {
    public static void main(String[] args) throws IOException {
        ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext("consumer.xml");
        OrderService orderService = ioc.getBean(OrderService.class);
        orderService.initOrder("1");
        System.out.println("调用完成");
        System.in.read();
    }
}
~~~



3）配置服务提供者

[所有dubbo标签的作用](https://dubbo.apache.org/zh/docs/v2.7/user/references/xml/)

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.wcy.dubboorder.gmall.impl"></context:component-scan>

    <dubbo:application name="dubboTest2"></dubbo:application>

    <dubbo:registry address="zookeeper://127.0.0.1:2181"></dubbo:registry>

    <!--  声明需要调用的远程服务的接口，生成远程服务代理  -->
    <dubbo:reference id = "userService" interface="com.wcy.dubbotestinterface.service.UserService"></dubbo:referen##ce>

</beans>
~~~



## 1.5 监控中心（springboot版hello world）

dubbo-monitor-simple 简单的监控中心

我所下载的[dubbo-monitor-simple下载链接](https://github.com/strato-sail/strato-sail.GitHub.io/tree/main/_posts/dubbo)

用`mvn package` 命令打包完成后生成了`jar`包和压缩包，将压缩包解压后在`bin`目录里有启动的批处理程序（start.bat）。其中注意在`conf`里目录下的配置文件中，注册中心地址、访问端口（默认8080）需要配置好。

双击`start.bat`，浏览器访问`http://localhost:8080/` 进入监控页面：

![](\img\in-post\dubbo\dubbo-11.png)

[所有dubbo标签的作用](https://dubbo.apache.org/zh/docs/v2.7/user/references/xml/)中找到`dubbo:monitor`，

在服务消费者和服务提供者的` xml `中加上一句：

~~~xml
<!--监控中心协议，如果为protocol=“registry”，表示从注册中心发现监控中心地址，否则直连监控中心。-->
<dubbo:monitor protocol="registry"></dubbo:monitor>
~~~





-----

**下面为springboot应用**

### 服务提供者

1）导入`dubbo-starter`依赖

```xml
<!--这个包自动导入了dubbo，zookeeper，curator（操作zookeeper的客户端）-->
<!-- https://mvnrepository.com/artifact/com.alibaba.boot/dubbo-spring-boot-starter -->
<dependency>
    <groupId>com.alibaba.boot</groupId>
    <artifactId>dubbo-spring-boot-starter</artifactId>
    <version>0.2.0</version>
</dependency>
```

2）在`application.properties`配置`dubbo`

~~~yml
dubbo:
  application:
    name: user-service-provider
  registry:
    address: 127.0.0.1:2181
    protocol: zookeeper
  protocol:
    name: dubbo
    port: 20880
  monitor:
    protocol: registry
~~~

暴露服务**之前**是在`provider.xml`中：很繁琐，需要自己配置bean

~~~xml
 <!-- 4. 暴露服务 interface接口全限定类型 ref指向服务真正的实现对象-->
<dubbo:service interface="com.wcy.dubbotestinterface.service.UserService" ref = "userServiceImpl"></dubbo:service>
<!-- 服务的实现bean  -->
<bean id = "userServiceImpl" class="com.wcy.dubboservice.gmall.impl.UserServiceImpl"></bean>
~~~

**现在**在需要暴露的服务上使用注解：和`@Component`同位置

~~~java
@com.alibaba.dubbo.config.annotation.Service   //暴露服务
~~~

在 springboot主启动类 `@SpringBootApplication`上添加注解：

~~~java
@com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo  //开启基于注解的dubbo功能
~~~



### 服务消费者

1）导入`dubbo-starter`依赖

2）在`application.yaml`配置`dubbo`

~~~yaml
dubbo:
  application:
    name: user-service-consumer
  registry:
    address: 127.0.0.1:2181
    protocol: zookeeper
  monitor:
    protocol: registry
    
server:
  port: 8081   //服务提供者在8080端口
~~~

**之前**声明需要调用的远程服务接口，是在`consumer.xml`中：很繁琐，需要自己配置bean

~~~xml
<!--  声明需要调用的远程服务的接口，生成远程服务代理  -->
<dubbo:reference id = "userService" interface="com.wcy.dubbotestinterface.service.UserService"></dubbo:reference>
~~~

**现在**在需要自动注入的组件上使用注解：和`@CAutowired`同位置

~~~java
@com.alibaba.dubbo.config.annotation.Reference   //从配置中心自动发现组件
~~~

在 springboot主启动类 `@SpringBootApplication`上添加注解：

~~~java
@com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo  //开启基于注解的dubbo功能
~~~

### 启动

两个springboot应用分别启动后，注册中心页面出现服务：

![](\img\in-post\dubbo\dubbo-12.png)

访问`http://localhost:8081/initOrder?uid=1`后出现`json`格式的`responseBody`则成功。

# 2 踩过的坑

- `alibaba`的和`apache`的`dubbo-starter`的各个注解不太一样

  比如`apache`的`starter`使用的服务注册注解为`@DubboService`而`alibaba`的为`@Service`

  

- 服务调用者启动后控制台打印：

  ~~~she
  INFO 29008 --- [           main] c.wcy.dubboorder.DubboorderApplication   : Started DubboorderApplication in 11.345 seconds (JVM running for 12.58)
  ~~~

  原因是springboot配置有问题，pom文件未导入`web-starter`：

  ~~~xml
  <dependency>
  	<groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  ~~~

  



